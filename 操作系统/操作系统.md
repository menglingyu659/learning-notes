## 操作系统 ——学堂在线 ——清华——操作系统课程

### <u>参考教材</u>

<img src="img/教材1.jpg" style="zoom:33%;" />

<img src="img/教材2.jpg" style="zoom:33%;" />

### <u>Linux创始人相关书籍</u>

<img src="img/Linux.jpg" style="zoom: 25%;" />

### <u>教学内容</u>

- #### 操作系统结构

- #### 中断及系统调用

- #### 内存管理

- #### 进程及线程

- #### 处理机调度

- #### 同步互斥

- #### 文件系统

- #### I/O子系统

---

### <u>什么是操作系统</u>

- #### 是一个控制程序

  - ##### 一个系统软件

  - ##### 控制程序执行过程，防止错误和计算机的不当使用

  - ##### 执行用户程序，给用户程序提供各种服务

  - ##### 方便用户使用计算机系统

- #### 是一个资源管理器

  - ##### 应用程序与硬件之间的中间层

  - ##### 管理各种计算机软硬件资源

  - ##### 提供访问计算机软硬件资源的高效手段

  - ##### 解决资源访问冲突，确保资源公平使用

---

### <u>操作系统的地位</u>

<img src="img/操作系统的地位.jpg" style="zoom:33%;" />

<img src="img/操作系统的地位1.jpg" style="zoom:33%;" />

- #### 操作系统软件的分类

  <img src="img/操作系统软件的分类.jpg" style="zoom:33%;" />

- #### 操作系统软件的组成

  - ##### Shell —— 命令行接口

    - ##### 通过键盘操纵

    - ##### 方便用户进行命令输入

  - ##### GUI —— 图形用户接口

    - ##### WIMP

    ==（视窗(Window)、图标(Icon)、选单(Menu)、指标(Pointer)）==

    - ##### 直接操作和所见即所得

  - ##### Kernel —— 操作系统的内部

    - ##### 执行各种资源管理等功能

- #### 操作系统与用户关系

<img src="img/操作系统与用户的关系.jpg" style="zoom: 25%;" />

- #### ucore教学操作系统内核

<img src="img/ucore教学操作系统内核.jpg" style="zoom:25%;" />

---

### <u>操作系统内核特征</u>

- #### 并发：

  - ##### 计算机系统中同时存在多个运行的程序，需要OS管理和调度

- #### 共享：

  - ##### 宏观上，“同时”访问

  - ##### 微观上，互斥共享

- #### 虚拟：

  - ##### 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务

- #### 异步

  - ##### 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知

  - ##### 只要运行环境相同，OS需要保证程序运行的结果也要相同

---

### <u>操作系统演变</u>

- #### 单用户系统

- #### 批处理系统

- #### 多程序系统

- #### 分时：在执行前一个作业期间会有一个时间中断，在中断时候执行下一个作业，好处是有可能第一个作业执行时间很长，而第二个执行时间很短，这样第二个就可以不用一直等待第一个执行完，在总时间上是延长了，但是对于每个作业调度达到公平

- #### 个人计算机：每个用户一个系统

- #### 分布式计算：每个用户多个系统

---

### <u>操作系统结构</u>

- #### 微内核结构

  	<img src="img/微内核结构.jpg" style="zoom: 25%;" />

- #### 外核结构

  	<img src="img/外核结构.jpg" style="zoom:25%;" />

  -  内核只提供硬件和操作系统之间的安全绑定，让每个操作系统决定如何处理和调度资源，这样能够让系统更好的兼容不同操作系统

- #### VMM虚拟机管理器

  <img src="img/虚拟机管理器.jpg" style="zoom:25%;" />

  - 管理器负责资源隔离，操作系统复杂资源管理
  
---

### <u>计算机加电之后发生了什么？</u>

 - ### 1. 启动：

   - #### 内存分为`RAM`（随机访问存储）和`ROM`（只读存储），计算机会从只读存储中读取并使用系统的初始化代码（我们上一次使用的记录）

      <img src="img/计算机通电后.jpg" style="zoom:25%;" />

   - #### 通电时计算机会从磁盘上读取相关信息（实模式下），而为了访问磁盘设备就需要`BIOS`的一系列服务

      - ##### BIOS不直接读取数据是因为文件系统多种多样BIOS不认识，所以需要磁盘上的加载程序来读取，然后再通过加载程序来读取操作系统，然后读取操作系统内核代码来运行操作系统

      <img src="img/BIOS.jpg" style="zoom:25%;" />

      - ##### BIOS：保存基本输入输出程序、系统配置信息、开机后程序自检程序和系统自启动程序一系列相关信息

         - ##### BIOS以中断调用的方式提供基本输入输出，主要包括：

            - INT 10h：字符显示；
            - INT 13h：磁盘扇区读写；
         	- INT 15h：检测内存大小；
   			- INT 16h：键盘输入
         
      - ##### BIOS只能在`X86`的实模式下工作，如果操作工作在保护模式下BIOS上述的==4==个基本输入输出就不能使用

    - #### 总结：总流程大致为，通电之后读取BIOS，BIOS从磁盘上读取加载程序，加载程序读取操作系统内核代码

      - ##### 计算机启动流程：因为一个计算机有可能有多个计算机系统，也就对应了多个分区，BIOS通过主引导记录找到活动分区，通过活动分区找到对应的系统来启动加载程序，加载对应的操作系统内核，并将操控权给操作系统内核

   	<img src="img/计算机启动流程.jpg" style="zoom:25%;" />

   ​				cpu初始化：

   <img src="img/cpu初始化.jpg" style="zoom: 33%;" />

   - #### BIOS初始化过程
     
       - ##### 硬件自检POST
        - ##### 检测系统中内存和显卡等关键部件的存在和工作状态
        - ##### 查找并执行显卡等接口卡`BIOS`，进行设备初始化
        - ##### 执行计算机系统的`BIOS`，并进行系统检测
          
            - ###### 检测和配置系统中安装的即插即用设备
         - ##### 更新`CMOS`中的扩展系统配置数据`ESCD`（主要是将所有硬件设备（也包含即插即用）列一个系统配置表）
         - ##### 按指定启动顺序从软盘、硬盘或光驱启动
       
   - #### 加载程序细化
     
      - ##### 加载程序从文件列表中读取一个启动配置文件（启动配置文件在不同操作机系统间是不同的），根据不同的操作系统（windows、linux等）的启动配置，依据配置加载指定操作系统内核，并将控制权转给操作系统内核
      

      
      <img src="img/加载程序.jpg" style="zoom: 25%;" />
      
      

- ### 2.中断、异常和系统调用：

  - ##### 为什么需要中断、异常和系统调用
  
    - ##### 在计算机运行中，内核是被信任的第三方
  
    - ##### 只有内核可以执行特权指令
  
    - ##### 方便应用程序
  
  - ##### 中断和异常希望解决什么问题
  
    - ##### 当有外设连接计算机的时候，比如==敲击键盘这个时候操作系统应该作出反应，这时候就需要操作系统中断正在进行的任务，去执行键盘任务，这样才能给用户带来良好使用效果==
  
    - ##### 当应用程序处理意想不到的行为时，需要能处理这个异常，比如==当应用程序中一个数除以了一个`0`，操作系统就会告知应用程序异常，应用程序中断并把占用的资源返还给操作系统==
  
  - ##### 系统调用需要解决什么问题
  
    - ##### 系统调用和功能调用~函数库提供的服务~，有什么区别？
  
    - ##### 用户应用程序是如何得到系统服务的？
  
      - ###### 当应用程序使用函数库时，内核、应用程序和函数库会间接的通过系统调用接口使用操作系统内核的服务，比如==要读取一个文件，会通过操作系统的一个磁盘读写`系统调用接口`，通过调用这个接口来通知操作系统读取这个文件内容，操作系统读取后再将内容给应用程序==
  
  - ##### 内核的进入和退出:<!--这个图就是上面中断、异常和系统调用操作的图例-->
  
    <img src="img/内核进入和退出.jpg" style="zoom:25%;" />
  
    <img src="img/比较.jpg" style="zoom:25%;" />
  
    上图中：中断 -^源头^-> 外部设备，异常 ---> 应用程序意想不到的行为，系统调用 ---> 应用程序请求某些操作所进行的调用
  
    ​				中断 -^响应方式^-> 异步，异常 ---> 同步，系统调用 ---> 异步或同步
  
    ​				中断 -^处理机制^-> 持续，对用户程序是透明的，异常 ---> 杀死或重新执行意想不到的应用程序指令，系统调用 ---> 等待和持续
  
  - ##### 定义
  
    - ##### 系统调用（System Call）：应用程序==主动==向操作系统发出的服务请求
  
    - ##### 异常（Exception）：非法指令或者其他原因导致==当前指令执行失败==*（如：内存出错或者一个数字除以0）*后的处理请求
  
    - ##### 中断（Hardware Interrupt）：来自==硬件设备==*（如键盘）*的处理请求，<!--比如当键盘输入数据时会将数据放在缓存区中，而操作系统看见缓存区有数据，就会中断现在执行的任务，区读取缓存区的数据-->
  
  - ##### 中断处理机制
  
    - ##### 硬件的处理：在cpu初始化时设置中断使能标志，只有==cpu初始化完成==才会处理中断请求，在初始化完成之前cpu时不知道如何处理终端的
  
    - ##### 软件的处理：
  
    	- ###### 现场保存（编译器）
  	
    	- ###### 中断服务处理（服务例程）
    	
    	- ###### 清楚中断标记（服务例程）
    	
    	- ###### 现场恢复（编译器）
    
    <img src="img/中断处理机制软件.jpg" style="zoom:25%;" />
  
  - ##### 中断嵌套
  
    - ##### 硬件中断服务例程可被打断
  
      - ###### 不同硬件中断源头可以在中断处理时出现，比如==在处理一个中断时可以出现另一个中断，操作系统会根据优先级来选择处理哪一个中断，或者交替处理中断==
  
      - ###### 硬件中断服务例程中需要临时禁止中断请求，比如==当电源有问题时，就会禁止其他中断任务，只执行电源相关处理==
  
      - ###### 中断请求会一直保持到cpu做出响应，比如==一个键盘输入中断只有cpu从缓存区取出数据做处理时中断请求才会停止==
  
    - ##### 异常服务例程可被打断
  
      - ###### 异常服务例程执行时可能出现硬件中断，==在执行异常处理时，出现了其他异常导致这个异常被中断==
  
    - ##### 异常服务例程可嵌套
  
      - ###### 异常服务例程可能出现缺页，比如==在执行异常处理时，这个异常处理又出现了异常==
  
  - ##### 中断、异常和系统调用的开销
  
    - ##### 开销超过函数调用
  
    - ##### 中断、异常和系统调用
  
      - ###### 引导机制
  
      - ###### 建立内核堆栈
  
      - ###### 验证参数
  
      - ###### 内核态映射到用户态的地址空间
  
        - 更新页面映射权限
  
      - ###### 内核态独立地址空间
  
        - TLB

---

### <u>存储管理（系统中的存储、内存是以字节为单位进行访问）</u>

- #### 计算机体系结构

  <img src="img/计算机体系结构.jpg" style="zoom: 25%;" />

- #### 存储操作

  - ##### cpu存在寄存器一般存数据，但是寄存器很小的（通常32bit或64bit），因此要想读写数据或指令就要从内存中读写，系统是32位就代表一次能从内存中读写`4字节`个数据或指令，如果有的数据或指令经常大量重复利用将这些数据或指令存在cpu的高速缓存中会使读写更快

- #### 内存层次

  <img src="img/内存层次.jpg" style="zoom:25%;" />

- #### 操作系统内存管理

  <img src="img/内存管理.jpg" style="zoom:25%;" />
  
  - ##### 操作系统内存管理方式
  
    - ##### 重定位：通过段寄存器的地址进行偏移来寻访正确内存的物理地址
  
    - ##### 分段：将数据，代码和堆栈分成相互独立的三块
  
    - ##### 分页：将内存分成最基本单位
  
    - ##### 虚拟存储
  
      - ###### 目前多数系统（如 Linux）采用按需式虚拟存储
  
    以上管理高度依赖硬件：**1.**与计算机存储架构紧耦合。 **2.**MMU（内存管理单元）：处理CPU存储访问请求的硬件
  
- #### 物理地址&逻辑地址

  - ##### 物理地址空间 —— 硬件支持的地址空间

    - ##### 起始地址0，直到MAX~sys~

  - ##### 逻辑地址空间 —— 在CPU运行的进程看到的地址

    - ##### 起始地址0，直到MAX~prog~

    - ##### 逻辑地址的生成<img src="img/逻辑地址生成.jpg" style="zoom:25%;" />

  - ##### 地址的生成时机和限制

    - ##### 编译时：在初始化时就将每个程序的物理地址分配好了（类似于以前的功能手机，不能自己往手机里面下载软件）

      - ###### 假设初始地址已知

      - ###### 如果初始地址改变需要重新编译

      - ###### 在物理内存上的存储时连续的

    - ##### 加载时：在编译阶段用逻辑地址来存储，在程序加载时通过偏移将逻辑地址放到物理地址中（类似于智能手机，可以自己下载程序）

      - ###### 如编译时初始地址未知，编译器需生成可重定向的代码

      - ###### 加载时，生成绝对地址

      - ###### 在物理内存上的存储时连续的

    - ##### 执行时：特定指令会映射某一个区域，将这个区域存到物理内存中，在执行到特定指令时候通过映射寻访物理内存，这样即使这个区域在物理内存中的位置改变了，也能正确找到自己存储的资源（一般用于虚拟存储的系统中）

      - ###### 执行时代码可移动

      - ###### 需地址转换（映射硬件支持）

  - ##### 地址的生成过程：在一段代码执行时`CPU`先看到一段逻辑地址，然后通过`MMU`将逻辑地址转换成物理地址，`CPU`中的控制器再将物理地址和相关的总线控制信号送到总线上，存储单元（存储芯片）会识别总线上的物理地址和总线控制信号（==读操作==或==写操作==），对内存相应地址进行读或者写。

    <img src="img/地址生成过程.jpg" style="zoom:25%;" />

  - ##### 地址检查：`CPU`在生成逻辑地址时会先检查偏移量是不是在段长度（0到MAX~prog~）之内，如果正确，段长度再加上段基址（基础地址），总和最后到物理地址中。==段长度和段基址都是操作系统设置的==

    <img src="img/地址检查.jpg" style="zoom:25%;" />

- #### 连续内存分配

  ##### ==已分配的分区列表：将所有已分配的分区的信息*（分区大小、物理地址等）*存放在操作系统维护的数据结构中==

  ##### ==空闲分区列表：将所有空闲分区的信息*（分区大小、物理地址等）*存放在操作系统维护的数据结构中==

  - ##### 连续内存分配和内存碎片

    <img src="img/连续内存分配和内存碎片.jpg" style="zoom: 25%;" />

    - ##### 连续内存分配：给进程分配一块不小于指定大小的连续的物理内存区域

    - ##### 内存碎片：空闲内存不能被利用

      - ###### 外部碎片：两个进程之间的进程被释放，所释放的内存过小，其他进程都不能利用这部分进程

      - ###### 内部碎片：分配给进程内部的一些无法利用的区域，分配单元要取整所导致的，比如==（一个进程需要510`byte`空间，但是分配字节只能分配2的整数幂所以会分配512`byte`，余下的2`byte`无法被利用）==

  - ##### 连续内存分配：动态分区分配

    - ##### 动态分区分配：当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块），分区的地址时连续的

    - ##### 操作系统需要维护的数据结构（哪些分区空闲哪些分区被分配）

      - ###### 所有进程已分配的分区

      - ###### 空闲分区

    - ##### 动态分区分配策略（为了找分区）

      - ###### 最先匹配（First fit）：内存从前到后找到哪个分区合适就用哪个分区

        - 原理&实现：
          1. 空闲分区按照地址顺序进行排序
          2. 分配过程时，搜索一个合适的分区
          3. 释放分区时，检查相邻是否由空闲分区，与相邻的空闲分区合并
        - 优点：
          1. 简单
          2. 在高地址空间有大块的空闲分区
        - 缺点：
          1. 外部碎片
          2. 分配大块时较慢

      - ###### 最佳匹配（Best fit）：将所有内存分区都遍历一遍，找到比需要内存长度大的最少的分区

        - 原理&实现
          1. 空闲分区列表按照==由小到大==进行排序
          2. 分配时，查找一个合适的分区
          3. 释放时，查找并合并==地址临近==的分区，因为空闲分区列表时按照大小进行排序，但是释放时找临近分区还是要找==地址临近==的分区
        - 优点：
          1. 避免大的分区被拆分
          2. 可以减小外部碎片的大小
          3. 相对简单
        - 缺点
          1. 外部碎片过小难以被利用
          2. 释放分区缓慢
          3. 容易产生过多的无用小内存碎片

      - ###### 最差匹配（Worst fit）：找内存中剩余的内存分区最大的那个

        - 原理&实现：
          1. 空闲分区列表按照==由大到小==进行排序
          2. 分配时，选最大分区
          3. 释放时，找==地址临近==的分区合并，并将合并后的分区放在分区列表中，并将列表排序
        - 优点：
          1. 中等大小的分配较多时，效果最好
          2. 避免了过多的小碎片
        - 缺点：
          1. 释放分区缓慢
          2. 外部碎片
          3. 容易破坏大的分区，导致难以找到可分配的大分区

  - ##### 碎片整理：通过调整进程占用的分区位置来减少或避免分区碎片

    - ##### ##### 碎片紧凑：通过移动分配给进程的内存分区，以合并外部碎片

      - ###### 条件：

        - ###### 所有的应用程序可动态重定位

        - 只有处于等待状态的进程才可以移动，正在执行的进程不去移动

        - 开销：是否有必要进行紧凑，不要为了一小块区域去移动

    - ##### 分区对换（Swappi in/out）：通过抢占并回收处于等待状态进程的分区，将等待状态进程占用的相关资源存储到外存，以增大内存可用空间，==早期的多进程就是通过对换分区方式来实现的，主要是进程间在内存上的交替运行==

  - #### 伙伴系统（Buddy System）：

    - ##### 内存分配：<img src="img/伙伴系统内存分配.jpg" style="zoom:25%;" />

    - ##### 释放和合并：<img src="img/释放合并.jpg" style="zoom:25%;" />

- #### 非连续内存分配

  - 